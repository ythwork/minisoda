# minisoda
### 목차
  - 프로젝트 소개
  - 데이터베이스
  - 트랜잭션과 퍼시스턴스 컨텍스트에 대해
  - 트랜잭션 격리 수준 
  - 클래스 설명 - domain layer
  - 클래스 설명 - repository layer
  - 클래스 설명 - service layer
  - 클래스 설명 - web layer
---

## 프로젝트 소개
  - 기술 면접에 활용하고자 간단한 송금 REST API 프로젝트를 진행했습니다.
  - 지원 포지션이 JPA와 REST를 주로 활용해야 하므로 두 분야에 대해 많이 생각하고 정리하며 구성했습니다.
  - 이번 프로젝트는 데이터베이스와 JPA가 큰 주제를 이루기 때문에 개발 DB로 H2가 아닌 mariaDB를 사용했습니다.
  - REST API 구현에는 HATEOAS(Hypermedia As The Engine Of Application State)를 활용했습니다.  
  - 프로젝트 구성 
    - Spring boot 2.3.4  
    - JPA 
    - mariadb 
    - STS4
---

## 데이터베이스
  ERD
  ![minisoda_erd](https://user-images.githubusercontent.com/24449555/97912134-bc343900-1d8f-11eb-838a-6507f232a1e5.jpeg)
  - 이번 프로젝트에서 사용한 데이터베이스의 스키마입니다. 깃허브에 minisoda.sql 파일에 DDL SQL을 모아두었습니다.
  스토리지 엔진은 디폴트 엔진인 InnoDB를 사용했습니다. 그 이유는 다음과 같습니다. 인덱스는 일반적으로 B+ 트리를 이용해 튜플에 대한 참조를 정렬합니다. B+ 트리는 메모리가 아니라 하드디스크에 상주하는 자료구조입니다. 하드디스크에서 데이터를 가져오려면 수백만 클럭이 소요되는데 이는 메모리에 비하면 매우 느립니다. 이에 BST의 장점은 가져오면서 하드디스크에 대한 접근 횟수를 최대한 줄여보고자 만들어졌습니다. BST의 장점은 자료의 삽입, 삭제, 탐색을 모두 O(log n)에 할 수 있다는 점입니다. B + 트리의 전 모델이라고 할 수 있는 B 트리는 BST의 노드가 키 값을 하나만 가지는데 반해 한 노드에 키가 여러개 있습니다. 이렇게 노드에 키를 많이 저장함으로써 접근 횟수를 줄일 수 있었습니다. B+ 트리는 이에 더해 리프 노드가 링크드 리스트로 연결되어 있습니다. 예를 들어 SELECT ... WHERE date BETWEEN t1 AND t2 라는 쿼리를 실행하고 이때 date에 인덱스가 있다면 t1에 대해 탐색을 한번하고 t2에 대해 탐색을 한번 하면 리프 노드에서 그 구간 사이의 모든 키 값을 탐색할 수 있습니다. InnoDB 엔진는 리프노드가 튜플에 대한 참조가 아니라 실제 튜플이라는 특징이 있습니다. PK는 자연스럽게 clustered key가 되어 pk를 where 절에서 검색 조건으로 쓰면 매우 빠른 특징이 있습니다. JPA는 composite key의 경우 surrogate key를 권장하는데 컨트롤러 메스드에서 @PathVariable로 id를 넘겨받아 service에서 튜플을 탐색하면 pk에 대한 탐색이 되므로 매우 빠르게 탐색할 수 있습니다. 제 개인적인 의견으로는 jpa의 pk전략과 InnoDB의 클러스터드 인덱스 정책은 매우 잘 어울린다고 생각합니다.    
  - 고려사항
    1. 정규화
      - 정규화는 partial dependency(2차)나 transitive dependency(3차)를 제거하며 테이블을 쪼개는 작업입니다. 필요할 때 조인을 통해 데이터를 합쳐 사용합니다. 
      - 일반적으로 스키마를 설계할 때 2차나 3차 등을 의식하며 테이블을 만들지는 않는 것 같습니다. 서로 '관련 있는' 필드를 한군데로 모으고 다른 테이블과 관계(relation)을 형성합니다. 프로그래밍 패러다임으로서의 OOP와 많이 달라보이지만 관계형 데이터베이스 이론은 OOP에서 파생했습니다. 물론 집합론의 영향이 더 크긴 하지만 정규화 이론을 들여다보면 자연스레 OOP가 떠오릅니다.
    2. 테이블 설명
      - member : 웹 서비스의 회원입니다. 이름을 first_name과 last_name으로 나누었는데 이번 프로젝트에서 구현하지는 않았지만 getName()이라는 getter 메서드를 두어 api에서 full_name 등과 함께 호환할 수 있습니다. JPA에서 entity로 구성할 때는 country ~ house_number는 address라는 임베디드 타입으로 만들었습니다. 이메일 컬럼에 인덱스를 만들었는데 이 인덱스는 중복 회원을 거르는데 사용합니다.  
      - openapi : 은행 통합 REST API를 간략하게 나타냈습니다. 외부 서비스이므로 api로 계좌 정보를 받아와야겠지만 미니 프로젝트이므로 테이블로 표현했습니다. 
      - bankcode : 은행 코드입니다. 카테고리나 기관은 코드로 다루는 게 나은데 그렇게 하지 않으면 튜플에 '소다은행'과 '소디은행'(오타)을 다르게 보고 만약 pk라면 새로운 키를 생성할 수도 있으므로 안전하게 코드 테이블을 만드는 것이 좋습니다. 
      - account : 사용자가 웹서비스에 등록한 계좌 정보입니다. 이 계좌를 통해 송금 서비스를 이용할 수 있습니다.
      - transaction : 거래 목록을 나타냅니다. account에 등록된 계좌를 이용해 송금을 할 수 있습니다. 잔고 등은 사용자가 다른 서비스나 은행 업무 등을 통해 변동될 수 있으므로 송금할 때마다 openapi에서 받아와 사용합니다. 이때 중요한 점이 트랜잭션의 격리 수준입니다. 일반적인 웹서비스는 데이터의 일관성보다 동시성을 중요하게 여기기 때문에 READ COMMITTED 수준에 비즈니스 특성에 따라 REPEATABLE READ를 사용합니다. 스프링의 경우 @version을 통해 애플리케이션 수준에서 이를 구현할 수 있습니다. 송금 서비스의 경우 송금할 때 READ COMMITTED은 위험할 것 같습니다. REPEATABLE READ에 더해 쓰기 잠금이 필요합니다. JPA에서는 비관적 락 PESSIMISTIC_WRITE 모드를 사용합니다. 내부적으로는 SELECT ... FOR UPDATE를 이용해 row level에서 쓰기 잠금을 합니다. 
    3. 송금할 때 트랜잭션 격리 수준과 잠금
      - 최근 DB는 대부분의 경우 락이 아니라 MVCC(multi-version concurrency control)로 REPEATABLE READ를 구현하여 우수한 동시성을 보장합니다. 락이라면 매우 많은 대기 시간이 발생하겠지만 MVCC는 non-blocking에 가깝습니다. 테이블에 접근하면 바로 요청한 row를 받아볼 수 있습니다. 구현 방식에 차이는 있지만 제가 사용한 InnoDB 엔진의 경우 rollback segment를 이용합니다. 그러므로 실제 테이블에는 항상 최신의 데이터가 있습니다. 누군가 테이블에 최신 데이터를 업데이트한다고 해도 현재 트랜잭션 내에서 조회했던 데이터가 변경되지는 않습니다. 내가 가진 SCN보다 최신의 데이터는 포함하지 않고 rollback segment에서 내 SCN보다 작은 가장 최신의 데이터를 가져와 튜플에 추가합니다. 이제 REPEATABLE READ를 트랜잭션 격리 수준으로 선택한다고 해도 성능상의 이슈는 없을 것 같습니다. 
      - 송금할 때는 튜플 단위로 쓰기 잠금을 걸어야 합니다. 이때는 SELECT ... FOR UPDATE를 사용해 로우 수준에서 락을 겁니다. UPDATE 구문의 경우 WHERE 절에 인덱스를 가진 컬럼이 있다면 이 인덱스에서 참조한 모든 로우를 잠급니다. WHERE 절에 두번째 조건이 있다면 실제 일치 범위는 잠긴 로우보다 적게 됩니다. 즉, 불필요하게 잠긴 로우가 발생하게 됩니다. 
      - 이번 프로젝트의 경우 송금할 때 여러 로우를 탐색하지 않고 openapi에서 두 개의 계좌 정보만 가져오기 때문에 UPDATE를 사용해도 불필요하게 잠기는 로우는 생기지 않습니다. 
    
